import { readFile, writeFile, mkdir, readdir, unlink } from 'fs/promises'
import { existsSync } from 'fs'
import { join } from 'path'
import { PATHS } from '../utils/paths'
import type { Word } from '../../../packages/app/features/game/types'

/**
 * Read words.json and return parsed Word array
 */
export async function readWordsJson(): Promise<Word[]> {
  const content = await readFile(PATHS.WORDS_JSON, 'utf-8')
  return JSON.parse(content) as Word[]
}

/**
 * Write words array to words.json
 */
export async function writeWordsJson(words: Word[]): Promise<void> {
  const content = JSON.stringify(words, null, 2) + '\n'
  await writeFile(PATHS.WORDS_JSON, content, 'utf-8')
}

/**
 * Save audio buffer to both Expo and Next.js directories
 */
export async function saveAudioFiles(audioBuffer: Buffer, filename: string): Promise<void> {
  // Ensure directories exist
  await mkdir(PATHS.EXPO_AUDIO_DIR, { recursive: true })
  await mkdir(PATHS.NEXT_AUDIO_DIR, { recursive: true })

  // Save to both locations
  await Promise.all([
    writeFile(join(PATHS.EXPO_AUDIO_DIR, filename), audioBuffer),
    writeFile(join(PATHS.NEXT_AUDIO_DIR, filename), audioBuffer),
  ])
}

/**
 * Delete audio files from both Expo and Next.js directories
 */
export async function deleteAudioFiles(filename: string): Promise<void> {
  const expoPath = join(PATHS.EXPO_AUDIO_DIR, filename)
  const nextPath = join(PATHS.NEXT_AUDIO_DIR, filename)

  await Promise.all([
    existsSync(expoPath) ? unlink(expoPath) : Promise.resolve(),
    existsSync(nextPath) ? unlink(nextPath) : Promise.resolve(),
  ])
}

/**
 * Regenerate audio-assets.ts file based on current words.json
 */
export async function regenerateAudioAssets(): Promise<void> {
  const words = await readWordsJson()

  // Generate the audio asset map
  const audioAssetMapEntries = words
    .map((word) => {
      const filename = word.audioUri
      return `  '${filename}': require('./assets/audio/${filename}'),`
    })
    .join('\n')

  const content = `// Audio asset mapping for Expo
// This file maps audio filenames to their require() paths
// Paths are relative to apps/expo/ (where Metro bundler resolves from)
// Auto-generated by CLI - do not edit manually

export const audioAssetMap: Record<string, any> = {
${audioAssetMapEntries}
}

`

  await writeFile(PATHS.EXPO_AUDIO_ASSETS, content, 'utf-8')
}

/**
 * Get all audio filenames currently in the directories
 */
export async function getExistingAudioFilenames(): Promise<string[]> {
  const expoFiles = await readdir(PATHS.EXPO_AUDIO_DIR)
  const nextFiles = await readdir(PATHS.NEXT_AUDIO_DIR)

  // Return union of both sets (MP3 files only)
  const allFiles = new Set([...expoFiles, ...nextFiles])
  return Array.from(allFiles).filter((f) => f.endsWith('.mp3'))
}

